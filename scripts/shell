#!/usr/bin/env python

import datetime
import logging
import os
from os import path
import re
import sys
import time

import pip
from sh import bash, tail
from ansi2html import Ansi2HTMLConverter

LOG = logging.getLogger('bash')

format_log_name = '{name}'.format
ROOT_DIR = path.dirname(path.dirname(path.abspath(__file__)))
format_log_path = path.join(
    ROOT_DIR, 'logs', '{timestamp}_{description}.log').format
TIMESTAMP_FORMAT = '%y-%m-%d_%H:%M:%S'
LOG_FORMAT = '%(asctime)-15s | %(message)s'


def timestamp():
    return datetime.datetime.now().strftime(TIMESTAMP_FORMAT)


def setup_lonnging(command, level=logging.WARNING):
    logging._acquireLock()
    try:
        root = logging.root
        if len(root.handlers) == 0:
            root.setLevel(logging.DEBUG)

            formatter = logging.Formatter(LOG_FORMAT)

            stream_handler = logging.StreamHandler()
            stream_handler.setLevel(level)
            stream_handler.setFormatter(formatter)
            root.addHandler(stream_handler)

            description = command.split('#', 1)[-1].strip()

            log_path = format_log_path(
                timestamp=timestamp(), description=description.strip())
            while path.isfile(log_path):
                time.sleep(.1)
                log_path = format_log_path(timestamp=timestamp())

            if path.isdir(path.dirname(log_path)):
                file_handler = logging.FileHandler(log_path, 'wt')
                file_handler.setLevel(logging.INFO)
                file_handler.setFormatter(formatter)
                root.addHandler(file_handler)
            else:
                log_path = None

            return log_path

    finally:
        logging._releaseLock()


def main(command):
    log_path = setup_lonnging(command)

    name = 'bash'
    logger = logging.getLogger(name)

    logging.getLogger('sh').setLevel(logging.WARNING)

    output_logger = logging.getLogger('out')
    def log_output(msg):
        output_logger.info(msg[:-1])

    error_logger = logging.getLogger('err')
    def log_error(msg):
        error_logger.info(msg[:-1])

    try:
        result = bash('-x', '-c', command, _out=log_output, _err=log_error)
    except sh.ErrorReturnCode as error:
        result = error.exit_code
        log_tail = ""
        if log_path:
            log_tail = tail('-n', '100', log_path)
        LOG.error(
            'Error executing command:\n'
            '    Command: %s\n'
            '    Exit code: %s\n'
            '    Log file: %s\n'
            '%s',
            command, error.exit_code, log_path, log_tail)
    else:
        result = 0

    if log_path:
        with open(log_path) as ansi_log:
            ansi = ''.join(ansi_log)

        new_log_path = os.path.splitext(log_path)[0]
        if result == 0:
            new_log_path += '_SUCCESS'
        else:
            new_log_path += '_FAILED'

        # write file without colors
        with open(new_log_path + '.txt', 'wt') as txt_file:
            txt_file.write(re.compile(r'\x1b[^m]*m').sub('', ansi))

        with open(new_log_path + '.html', 'wt') as html_file:
            html_file.write(Ansi2HTMLConverter().convert(ansi))

    return result


if __name__ == '__main__':
    exit(main(sys.argv[2]))
