#!/usr/bin/env python

import datetime
import gzip
import logging
import os
from os import path
import re
import sys
import time

import pip
from ansi2html import Ansi2HTMLConverter
from sh import bash, tail, ErrorReturnCode

LOG = logging.getLogger('bash')

format_log_name = '{name}'.format
ROOT_DIR = path.dirname(path.dirname(path.abspath(__file__)))
format_log_path = path.join(
    ROOT_DIR, 'logs', '{timestamp}_{description}.raw').format
TIMESTAMP_FORMAT = '%y-%m-%d_%H:%M:%S'
LOG_FORMAT = '%(asctime)-15s | %(message)s'


def timestamp():
    return datetime.datetime.now().strftime(TIMESTAMP_FORMAT)


def setup_lonnging(command, level=logging.WARNING):
    logging._acquireLock()
    try:
        root = logging.root
        if len(root.handlers) == 0:
            root.setLevel(logging.DEBUG)

            formatter = logging.Formatter(LOG_FORMAT)

            stream_handler = logging.StreamHandler()
            stream_handler.setLevel(level)
            stream_handler.setFormatter(formatter)
            root.addHandler(stream_handler)

            description = command.split('#', 1)[-1].strip()

            log_path = format_log_path(
                timestamp=timestamp(), description=description.strip())
            while path.isfile(log_path):
                time.sleep(.1)
                log_path = format_log_path(timestamp=timestamp())

            if path.isdir(path.dirname(log_path)):
                file_handler = logging.FileHandler(log_path, 'wt')
                file_handler.setLevel(logging.INFO)
                file_handler.setFormatter(formatter)
                root.addHandler(file_handler)
            else:
                log_path = None

            return log_path

    finally:
        logging._releaseLock()


def main(command):
    log_path = setup_lonnging(command)

    name = 'bash'
    logger = logging.getLogger(name)

    logging.getLogger('sh').setLevel(logging.WARNING)

    output_logger = logging.getLogger('out')
    def log_output(msg):
        output_logger.info(msg[:-1])

    error_logger = logging.getLogger('err')
    def log_error(msg):
        error_logger.info(msg[:-1])

    logger.info('Start executing commmand: %s', command)

    try:
        bash('-x', '-c', command, _out=log_output, _err=log_error)

    except ErrorReturnCode as error:
        result = error.exit_code
        label = "FAILED"
        severity = logging.ERROR

    except Exception:
        result = 1
        label = "ERROR"
        severity = logging.ERROR
        logger.exception('Internal error.')

    except BaseException:
        result = 1
        severity = logging.WARNING
        label = "INTERRUPTED"

    else:
        result = 0
        label = 'SUCCESS'
        severity = logging.INFO

    if result != 0:
        LOG.log(
            severity,
            'Error executing command:\n'
            '    Command: %s\n'
            '    Status: %s\n'
            '    Exit code: %s\n'
            '    Log file: %s\n',
            command, label, result, log_path)
        if log_path:
            tail('-n', '100', log_path, _out=sys.stderr)
    else:
        logger.info(
            'Commmand executed with success:\n'
            '    Command: %s',
            command)

    if log_path:
        with open(log_path, 'rb') as ansi_log:
            ansi = ' '.join(ansi_log)

        new_log_path = os.path.splitext(log_path)[0] + '_' + label

        # write txt file without colors
        with open(new_log_path + '.txt', 'wb') as ascii_file:
            ascii = re.compile(r'\x1b[^m]*m').sub('', ansi)
            ascii_file.write(ascii)

        # write html file with colors
        with open(new_log_path + '.html', 'wb') as html_file:
            converter = Ansi2HTMLConverter(dark_bg=True, scheme='xterm')
            try:
                html_file.write(converter.convert(ansi))
            except Exception:
                logger.exception(
                    'Unable to convert ansi 2 html, retry with ascii 2 html')
                bash('-c', "cat {} | ansi2html | > {}".format(
                    log_path, new_log_path + '.html'))

    return result


if __name__ == '__main__':
    exit(main(sys.argv[2]))
